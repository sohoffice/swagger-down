/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package sohoffice.swaggerdown

import io.swagger.v3.oas.models.OpenAPI
import io.swagger.v3.parser.OpenAPIV3Parser
import io.swagger.v3.parser.core.models.ParseOptions
import org.commonmark.ext.gfm.tables.TablesExtension
import org.commonmark.parser.Parser
import org.commonmark.renderer.html.HtmlRenderer
import picocli.CommandLine
import sohoffice.swaggerdown.preparer.*
import java.io.File
import java.io.StringWriter
import kotlin.system.exitProcess


class App {

  private val mustacheFactory = lazyOf(MyMustacheFactory())

  private val cmExtensions = lazy {
    listOf(TablesExtension.create())
  }

  private val cmMarkdownParser = lazy {
    Parser.builder()
        .extensions(cmExtensions.value)
        .build()
  }

  private val cmHtmlRenderer = lazy {
    HtmlRenderer.builder()
        .extensions(cmExtensions.value)
        .build();
  }

  private val preparers = listOf<Pair<String, Preparer>>(
      "api" to SimplePreparer(),
      "flatten" to ApiFlattenPreparer(),
      "singleLine" to NewlineToBrPreparer(),
      "trimString" to TrimPreparer(),
      "dashRepeater" to RepeaterPreparer("-")
  )

  fun parse(f: File): OpenAPI? {
    try {
      val opt = ParseOptions()
      opt.isResolve = true
      opt.isResolveFully = true

      return OpenAPIV3Parser().read(
          f.absolutePath,
          null,
          opt
      )
    } catch (e: Exception) {
      throw SdExitException(3, "Error parsing input file: $f")
    }
  }

  fun prepare(api: OpenAPI): Map<String, Any> {
    return preparers.fold(mutableMapOf<String, Any>(), { all, (id, proc) ->
      val r = proc.process(api)
      if (r != null) {
        all[id] = r
      }
      all
    })
  }

  fun merge(data: Map<String, Any>, flavor: String): String {
    val compiled = mustacheFactory.value.compile("sohoffice/swaggerdown/$flavor/index.mustache")
    val buffer = StringWriter()
    compiled.execute(buffer, data)
        .flush()
    return buffer.toString()
  }

  fun toHtml(md: String): String {
    val parser = cmMarkdownParser.value
    val parsed = parser.parse(md)
    return cmHtmlRenderer.value.render(parsed)
  }
}

fun main(args: Array<String>) {
  val options = Options()
  val cli = CommandLine(options)
  cli.isCaseInsensitiveEnumValuesAllowed = true
  cli.parseArgs(*args)
  if (options.helpRequested) {
    cli.usage(System.out)
    exitProcess(9)
  }

  try {
    val app = App()
    val api = app.parse(options.file ?: throw SdExitException(1, "Input file is mandatory"))
        ?: throw SdExitException(2, "Cannot parse API ${options.file}. Please make sure the path is valid and the content is OpenAPI v3")
    val data = app.prepare(api)
    val s = app.merge(data, options.flavor.name.toLowerCase())

    when (options.format) {
      Format.HTML -> {
        println(app.toHtml(s))
      }
      Format.MD -> println(s)
    }
  } catch (e: SdExitException) {
    println(e.message)
    println("")
    cli.usage(System.out)
    exitProcess(e.code)
  } catch (e: Exception) {
    println(e.message)
    println("")
    e.printStackTrace()
    cli.usage(System.out)
  }
}
